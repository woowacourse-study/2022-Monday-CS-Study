# 24. CSRF에 대해서 간단히 설명해주세요

CSRF란 **Cross-site Request Forgery**의 약자로, 번역하자면 **사이트 간 요청 위조**입니다. CSRF의 특징은 공격자가 사용자의 브라우저가 `권한`을 받았다는 것을 악용, 권한이 필요한 특정한 동작을 하도록 의도하는 공격이라는 점입니다. 즉, 인증 정보를 직접 탈취하지 않고 권한만 이용하는 공격이라고 볼 수 있습니다.

## 권한을 어떻게 이용하나요?

이는 쿠키의 동작 방식을 이용한 것입니다. 쿠키는 브라우저에 저장되고, 도메인 별로 지정되어 해당 도메인으로 요청을 보낼때 함께 보내집니다. 이 과정이 다른 사이트(Cross-site)일 때도 일어납니다. 즉, A라는 사이트에 로그인 한 뒤에 B라는 피싱 사이트에 접속했고, 피싱 사이트에 `A 사이트로 요청을 보내라` 라는 명령을 브라우저로 보내게 되면 A 사이트에 로그인 한 상태로 A 사이트에 요청을 보내게 되는 것입니다. 사실 이용자는 A 사이트에 요청을 보낼 의도가 아니었지만, 인증 받은 브라우저이기 때문에 서버 입장에서는 비정상적인 요청인지 알지 못합니다.

때문에 CSRF 공격이 이루어지려면 조건이 필요합니다.
- 사용자가 위조 요청의 대상 사이트에 로그인 되어 있음
- 피싱 사이트에 접속하거나 피싱 메일을 읽거나, XSS 공격을 당한 게시물 등을 사용자가 읽음

예를 들어 보겠습니다. `https://example.com`이라는 공격 대상 사이트의 관리자 권한을 가진 사용자가 로그인을 한 상태로 피싱 사이트에 접속하게 됩니다. 피싱 사이트에는 공격 대상 사이트로 관리자 계정의 비밀번호를 `admin`으로 바꾸도록 하는 스크립트가 숨어 있습니다. 사용자는 피싱 사이트에 접속하는 순간 스크립트를 읽게 되고, `https://example.com`으로 관리자 계정의 비밀번호 수정 요청을 보내게 됩니다.

`https://example.com`에서 이미 로그인을 했기 때문에, 쿠키에 이 사이트에 대한 로그인 정보가 담겨 있고 `https://example.com`으로 보내는 요청에는 이 쿠키가 함께 전달됩니다. 따라서 요청을 받은 서버는 사용자가 요청을 보냈다고 생각하여 관리자 계정의 비밀번호를 변경합니다. 

실제로 2008년 1800만여명의 개인정보가 유출된 옥션 개인정보 유출 사건 등이 이런 공격을 통해 이루어졌습니다.

## 어떻게 방어하나요?

CSRF를 방어하는 방법은 Referer를 조회하는 방법과 CSRF 토큰을 사용하는 방법이 있습니다.

### Referer 조회

HTTP 요청의 Referer 헤더에는 요청이 요청된 페이지의 정보가 담겨져 있습니다. 때문에 A 사이트의 서버로 요청을 보낼 때 정상적으로 A 사이트에 접속해서 요청을 보낸건지, 아니면 B라는 피싱 사이트를 보낸건지 Referer 헤더를 통해 검증하여 정상적인 사이트에서 온 요청만 허용하는 방법이 있습니다.

하지만 이 방법의 경우 같은 도메인 내에서 XSS 공격을 받은 페이지를 통해 요청이 올 경우 취약해질 수 있다는 단점이 있으며, Referer 헤더 역시 조작이 가능하다는 취약점이 있습니다.

### CSRF 토큰

CSRF 토큰을 사용하는 방법도 있습니다. CSRF 토큰은 요청이 실제로 사용자가 정상적으로 의도한 요청인지를 확인하기 위해 발행하는 난수 토큰으로, 서버에서 페이지로 CSRF 토큰을 발행해 준 뒤 요청에 이 CSRF 토큰을 포함하도록 하여 서버에서 토큰 값을 확인해 정상적인 요청인지 확인하는 방법이 있습니다. 스프링 시큐리티를 사용하면 보다 간편하게 CSRF 토큰을 사용할 수 있습니다.

### 사용자 정보를 쿠키에 저장하지 않음

사용자 정보를 쿠키에 저장하여 인증하는 방식을 사용하지 말고 Authorization 헤더를 쓰는 등의 방법을 사용하면 CSRF 공격을 방어할 수 있습니다. 또는 쿠키에 정보를 저장하더라도 권한이 거의 주어지지 않는 정보를 저장하는 방법도 있습니다. 예를 들어 JWT Token을 사용한 인증 인가를 구현할 때, 실제 권한을 담은 Access Token은 쿠키에 저장하지 않고, Access Token을 새로 발급받는 용도로만 쓸 수 있는 Refresh Token만 쿠키에 저장하는 식으로 활용할 수 있습니다.

그 외에도 OTP, CAPCHA 같은 방법도 CSRF 방어에 사용할 수 있습니다.

## SameSite란?

이런 CSRF 취약점을 막기 위해서 브라우저에는 SameSite라는 속성이 존재합니다. 과거 크롬이 80버전에서 SameSite 속성을 `none`에서 `lax`로 바꿔서 온갖 인증들이 마비되는 사건이 발생하기도 했었는데요, SameSite는 CrossSite에서 요청을 보낼 때 쿠키를 담을 것인가에 대한 정책입니다.

strict, lax, none 옵션이 존재하는데요, strict는 어떠한 쿠키도 CrossSite 요청에 담지 않고, lax는 Form GET과 같은 몇 가지 예외적인 요청에만 쿠키를 담고, none은 모든 요청에 쿠키를 담습니다.

다만 크롬, 엣지, 파이어폭스 등은 SameSite 옵션이 lax로 설정되어 있지만 사파리같이 아직 none으로 설정된 브라우저도 있기 때문에 SameSite에만 의존하면 안되겠습니다.
