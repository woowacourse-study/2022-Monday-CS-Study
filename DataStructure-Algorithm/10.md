### DFS, BFS에 대해서 설명해주세요.

- 먼저 `DFS`는 깊이를 우선하여 그래프를 탐색하는 알고리즘입니다. 특정 노드에서 출발해서 방문할 노드가 없을 때까지 한 방향으로 진행을 하다가 방문할 노드가 없을 때 가장 가까운 갈림길로 돌아가 탐색하는 것을 반복하게 됩니다. 주로 `재귀`나 `스택`을 이용하여 구현이 됩니다.

- 다음으로 `BFS`는 너비 우선 탐색으로, 너비를 우선하여 그래프를 탐색합니다. 특정 노드에서 출발해서 가까운 노드를 우선적으로 탐색하고 탐색했던 노드에서 또 인접한 노드를 탐색하는 것을 반복하게 됩니다. 주로 `큐`를 이용하여 구현이 됩니다.

- DFS, BFS 인접행렬로 구현할 경우 노드 n의 인접 노드를 찾는 과정에서 노드의 수 V만큼의 탐색을 해야하고 이를 V번 반복해야 하므로 `O(V^2)` 의 시간복잡도를 가진다. 하지만 인접 리스트 방식으로 구현할 경우 각 노드 리스트는 인접한 노드만 들어있기 때문에 간선의 수 E 만큼과 모든 노드를 탐색하므로 V를 더한 `O(V + E)` 의 시간복잡도를 가진다. 

--- 
### 그래프?
- 그래프는 노드와 간선으로 표현되는 자료구조이다. 그래프는 프로그래밍적으로 크게 인접 리스트, 인접 행렬 두 방식으로 표현이 가능하다.
  - 인접 행렬 방식
    ![IMG_CA967400CFD4-1](https://user-images.githubusercontent.com/52696169/182015032-76a4a62a-220c-4857-a4cf-ebf6f2b4a25f.jpeg)
    - 인접 행렬 방식 구현
        ```kotlin
        val x = Int.MAX_VALUE

        val graph = arrayOf(
        intArrayOf(0, 4, 5, x, x),
        intArrayOf(4, 0, x, 3, 2),
        intArrayOf(5, x, 0, x, x),
        intArrayOf(x, 3, x, 0, x),
        intArrayOf(x, 2, x, x, 0))
        ```

  - 인접 리스트 방식 표현
    ![IMG_B44DB5284223-1](https://user-images.githubusercontent.com/52696169/182015300-d10c5173-4640-4455-bd88-e439b7bc6368.jpeg)
    - 인접 리스트 방식 구현
        ```kotlin
        val graph = listOf(
            listOf(Pair(1, 4), Pair(2, 5)), // 노드 0 인접 리스트
            listOf(Pair(0, 4), Pair(3, 3), Pair(4, 2)), // 노드 1 인접 리스트
            listOf(Pair(0, 5)), // 노드 2 인접 리스트
            listOf(Pair(1, 3)), // 노드 3 인접 리스트
            listOf(Pair(2, 4))) // 노드 4 인접 리스트
        ```

### DFS, BFS구현
![IMG_40D8B5501094-1](https://user-images.githubusercontent.com/52696169/182024755-6b53b929-6e1d-4dd6-8cd2-35bfe7031c66.jpeg)

1. **DFS**
   - stack 활용한 구현
   ```kotlin
   fun dfs_stack(graph: List<List<Pair<Int, Int>>>, isVisit: BooleanArray, start: Int) {
        val stack: Stack<Int> = Stack()
        stack.add(start)
        print("$start ")
        isVisit[start] = true

        while (stack.isNotEmpty()) {
            val top = stack.peek()
            var haveWay = false

            for ((node, edge) in graph[top]) {
                if (!isVisit[node]) {
                    stack.push(node)
                    isVisit[node] = true
                    haveWay = true

                    print("$node ")
                    break
                }
            }
            if (!haveWay) {
                stack.pop()
            }
        }
    }
   ```
   - 재귀 활용한 구현
   ```kotlin
   fun dfs_recursion(graph: List<List<Pair<Int, Int>>>, isVisit: BooleanArray, n: Int) {
        isVisit[n] = true
        print("$n ")

        for ((node, edge) in graph[n]) {
            if (!isVisit[node]) {
                dfs_recursion(graph, isVisit, node)
            }
        }
    }
    ```

2. **BFS**
    ```kotlin
    fun bfs(graph: List<List<Pair<Int, Int>>>, isVisit: BooleanArray, start: Int) {
        val queue: Queue<Int> = LinkedList()
        queue.offer(start)

        while (queue.isNotEmpty()) {
            val nowNode = queue.poll()
            isVisit[nowNode] = true
            print("$nowNode ")

            for ((node, weight) in graph[nowNode]) {
                if (!isVisit[node]) {
                    queue.offer(node)
                }
            }
        }
    }
    ```

### 참고자료
https://lotuslee.tistory.com/48?category=965475
https://lotuslee.tistory.com/49?category=965475
이것이 코딩테스트다 (나동빈 저)