# 운영체제가 여러 프로그램을 동시에 실행하는 원리에 대해 설명해주세요

(CPU 싱글 코어 기반이라고 가정하면) 운영체제는 사실 여러 프로그램을 동시에 실행하는 것이 아니다. CPU 한 개당 동시에 처리할 수 있는 작업은 하나에 불과하다. 그래서 사실 CPU는 한 가지 일을 하다가 멈추고, 다른 일을 진행하고, 다시 멈추고, 다시 다른 일을 진행하는 등 여러가지 일을 빠르게 바꿔가면서 처리하고, CPU의 연산속도가 매우 빠르기 때문에 이 동작이 우리 눈에는 **동시에 실행하는 것 처럼** 보이는 것이다. (물론 CPU 코어가 많아지면 그만큼 실제로 동시에 여러 작업을 처리하는 것은 맞다.) 이렇게 여러 작업을 조금씩 처리하여 작업이 동시에 이루어지는 것처럼 보이게 하는 것을 **시분할 시스템(time sharing system)**,또는 **다중 작업(multitasking) 시스템**이라고 한다. 시분할 시스템이 도입되기 전에는 한 번에 한 가지 작업만 하고, 프로그램 실행 중간에 사용자가 데이터를 입력하거나 수정하는 것이 불가능한 **일괄 작업 시스템(batch job system)** 을 사용했고, 지금도 윈도우의 `.bat` 파일 등으로 그 흔적이 남아 있다.

> 실생활에서(?) 멀티태스킹  
> 어릴 적 우리를 설레게 했던 스타크래프트를 예시로 생각하면 쉽다. 컨트롤과 생산을 동시에 진행한다고 `멀티태스킹을 한다` 라고 하지만, 실제로는 매우 빠른 속도로 컨트롤과 생산을 왔다갔다 하는 것이다. 운영체제의 멀티태스킹도 이처럼 작업을 짧게 쪼개어 매우 빠른 속도로 여러 작업을 번갈아가며 처리하여 우리 눈에 보이기로는 동시에 여러 작업을 처리하는 것 처럼 보이는 것이다.
    
물론 현재 컴퓨터는 동시에 하나의 작업만 처리하지는 않는다. 현재는 CPU의 코어가 많아지면서 실제로 동시에 여러 개의 작업이 처리될 수 있다. 하지만 기껏해야 8개까지인 CPU의 코어 개수로 수십, 수백 개의 프로세스를 모두 한 번에 처리할 수는 없고, 결과적으로 여전히 각각의 CPU 코어들은 시분할 시스템으로 프로그램들을 처리하고 있다.

그렇다면 CPU가 어떤 순서로 프로그램들을 처리하는 지 결정은 어떻게 할 수 있을까? 작업 처리 순서를 결정하는 것을 **스케줄링**이라고 하는데, 운영체제가 할당되었던 CPU를 다시 뺏어올 수 있느냐 없느냐에 따라 선점형, 비선점형 스케줄링으로 나눌 수 있다.

비선점형 스케줄링은 운영체제가 CPU의 사용을 뺏어올 수 없기 때문에, 실행 중인 프로세스가 있다면 다른 프로세스를 할당할 수 없다. 즉, 실행 중인 프로세스가 대기 상태가 되거나 종료되지 않는 한 프로세스를 전환할 수 있다. 반면 선점형 스케줄링은 운영체제가 자체적으로 판단하여 다른 프로세스를 실행해야 한다면 CPU를 뺏어와 CPU가 다른 프로세스를 실행하도록 할 수 있다.

경우에 따라 비선점형이 선점형보다 유리한 경우도 있기는 하나, 우리가 사용하는 현대 OS에서 스케줄링 방식은 이미 선점형 스케줄링의 승리라고 봐도 무방하다.

앞서 CPU가 시분할 시스템을 이용해 동시에 여러 작업을 처리하는 것 처럼 보인다고 했는데, 한 작업이 끝나지 않았음에도 운영체제가 지정한 시간이 다 되면 다른 프로세스에 CPU를 내주어야 한다. 즉, 시분할 시스템은 선점형 스케줄링을 사용하는 것이다. 만약 비선점형 스케줄링을 사용한다면 일단 CPU를 점유하고 있는 작업이 끝나기 전 까지는 CPU를 되찾아 오지 못하고, 시분할 시스템이 이루어지지 못할 것이다.

시분할 시스템을 사용한다고 한다면 당연히 각각의 작업에 얼마씩의 시간을 할당할 것인지 정할 필요가 있다. 이렇게 다른 프로세스에 CPU를 뺏기기 전까지 얼만큼 일을 할 지 시간 단위를 **타임 슬라이스, 또는 타임 퀀텀** 이라고 한다. 타임 슬라이스의 크기는 적절히 결정해야 하는데, 타임 슬라이스가 너무 크면 타임 슬라이스 안에 작업을 다 처리해 버리니까 시분할 시스템을 사용하는 의미가 없을 것이다.(FIFO 방식과 동일해진다.) 그렇다면 타임 슬라이스를 무작정 작게 하면 되지 않냐고 할 수 있는데, 프로세스를 교체할 때 기존에 실행되던 프로세스의 값들을 PCB에 저장하고, 실행할 프로세스의 값들을 PCB에서 가져와 교체하는 작업이 필요하기 때문에 오버헤드가 발생한다. 따라서 타임 슬라이스가 작으면 작을수록 더 많은 오버헤드가 발생하는 것이다. 경험적으로 80% 정도의 CPU burst(프로그램 실행 중에 연속 적으로 CPU를 사용하는 단절된 구간)가 타임 슬라이스보다 작도록 타임 슬라이스의 크기를 정해야 한다고 한다.
