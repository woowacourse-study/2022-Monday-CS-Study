# (JPA 경험자 한정) JPA 를 이용할 때, JPQL 을 쓰는 경우가 종종 있는데, JPQL 을 쓰시며 좋았던 점과 불편했던 점을 말씀해 주세요.

JPA 자체만으로는 엔티티 매니저를 통해 식별자를 통한 엔티티 조회와 객체 그래프 탐색만 사용할 수 있습니다. 즉, 테이블의 특정 컬럼을 기준으로 한 조회 등 다양한 조회를 사용할 수 없습니다.

반면 JPQL은 기본적으로 SQL을 추상화한 쿼리 언어이기 때문에 다양한 조회가 가능합니다. 또한 SQL을 `추상화` 했다는 부분에서 알 수 있듯이 특정 데이터베이스에 의존하지 않는다는 JPA의 장점을 그대로 가지고 있습니다. 다만 JPQL은 일반 SQL과는 다르게 엔티티 객체를 대상으로(SQL은 테이블을 대상으로) 쿼리하기 때문에 객체 지향적으로 생각하면 좋을 수 있지만 기존 SQL을 사용하듯 사용하면 헷갈릴수도 있습니다.

JPQL의 단점으로는 SQL을 추상화하여 특정 데이터베이스에 의존하지 않도록 하고, 객체를 대상으로 조회하도록 했지만 여전히 String으로 된 쿼리라는 점입니다. 때문에 SQL처럼 개발자 의존적이며, 구문을 잘못 썼을 때 컴파일 타임에 이를 잡아낼 수 없고 런타임에서야 예외를 확인할 수 있었습니다.

불필요한 쿼리가 나가는 문제도 있었습니다. JPQL은 1차 캐시에서 데이터를 조회해오지 않습니다. 조회 이후 해당 데이터가 1차 캐시에 있는지를 검사할 뿐입니다. 그래서 이미 영속성 컨텍스트에 데이터가 들어 있어도 select 쿼리 자체는 나가게 됩니다. 그리고 JPQL은 객체의 연관관계를 신경쓰지 않습니다. 그래서 연관관계가 즉시로딩으로 설정되어 있으면 N+1 문제가 터져 순식간에 많은 쿼리가 나갔습니다. 다만 이 부분들은 식별자를 사용하지 않는 경우의 어쩔 수 없는 한계입니다.

또한 소소한 단점으로, JPQL에서는 limit, rand 같은 유용한 구문들이 없어서 네이티브 쿼리를 사용해야 하거나 비슷한 기능으로 우회해서 사용해야 한다는 불편함이 있었습니다.

이런 단점들을 해결하기 위해서, 작성해야 하는 코드의 양은 길어지지만 쿼리가 아닌 코드로 문제를 해결하고 컴파일 타임에 많은 예외를 잡아낼 수 있는 QueryDSL을 사용하여 좋은 결과를 냈습니다.
