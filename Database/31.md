# JPA에서 영속성 컨텍스트를 사용하므로써 얻을 수 있는 이점은 뭐라고 생각하시나요?

`엘리`

<img width="1293" alt="image" src="https://user-images.githubusercontent.com/45311765/194764147-15ee2a63-a870-4183-8778-8d90bf6f6476.png">

영속성 컨텍스트는 엔티티를 영구 저장하는 논리적인 저장소입니다. 영속성 컨텍스트는 어플리케이션과 DB 사이에 존재하므로써 여러 기능을 제공합니다. 

1. `조회시 1차 캐시 활용`: 영속성 컨텍스트에는 1번 조회한 데이터를 저장 해 놓는 1차 캐시가 있어 2번째 조회부터는 이 1차 캐시를 활용할 수 있습니다. 
2. `동일성 보장`: 이러한 1차 캐시에는 실제 객체를 저장해 놓기 때문에 조회 시 항상 주소가 같은 객체를 반환하므로 동등성을 보장할 수 있습니다. 
3. `트랜잭션을 지원하는 쓰기 지연`: 영속성 컨텍스트에는 쓰기 지연 SQL 저장소가 있어, SQL을 모아서 실행하므로써 DB와의 커넥션을 줄여줍니다. 
    - 자동 증가 아이디를 사용하는 경우에는 즉시 아이디를 알아야하기 떄문에 SQL을 바로 실행합니다.
    - JPQL로 작성한 메서드를 실행하는 경우 flush()가 바로 호출되기 때문에 SQL을 바로 실행합니다. 
    - 쓰기 지연 SQL 저장소의 모든 SQL을 같이 실행합니다. 
    - Hibernate의 경우 INSERT -> UPDATE -> DELETE 순서로 SQL이 실행됨에 주의해야합니다.
4. `변경 감지`: 1차 캐시에는 처음의 데이터를 저장해 놓은 스냅샷이 존재해, 엔티티의 필드 값만 변경하면 이를 감지하고 자동으로 UPDATE SQL을 만들어 실행해줍니다. 
5. `지연 로딩`: 영속성 컨텍스트에 엔티티가 아니라 프록시를 저장하고, 해당 프록시의 메서드 호출 시 DB에서 실제 데이터를 불러오는 방식으로 지연 로딩을 제공합니다. 

## 🤔 궁금증

- 영속성 전이, 고아 객체와 관련된 SQL은 dirty checking과 관계 없이 그때 그때 SQL이 쓰기 지연 SQL 저장소에 저장되는건가?
- flush()를 하고 나면 스냅샷이 갱신되나?
- 1차 캐시의 아이디는 어떤 형태로 저장되나?
- 만약 1차 캐시에 프록시가 저장되는 경우에 실제 엔티티는 1차 캐시에 저장되는 것이 아니라 그냥 heap에만 저장하는 건가?
