F12 팀 프로젝트를 진행하면서, 데이터가 적을 때는 몰랐지만 성능 테스트를 위해 많은 데이터를 넣고 쿼리를 실행해보니 정렬과 페이지네이션 문제로 슬로우 쿼리가 발생하고 있다는 것을 확인했습니다.

여러 테이블에 걸쳐서 슬로우 쿼리가 발생하고 있었지만, 테이블마다 결은 같기 때문에 한 테이블만을 기준으로 설명하겠습니다.

member
|id|github_id|
|:-:|:-:|
|1|Ohzzi|
|2|kbasat|
|3|RIANAEH|
|4|awesomeo184|
|5|injoon2019|
|...|...|

following
|id|following_id|follower_id|
|:-:|:-:|:-:|
|1|1|2|
|2|1|3|
|3|2|4|
|4|5|4|
|...|...|...|

following의 following_id와 follower_id에는 member id가 들어갑니다. 하지만 외래 키는 걸려 있지 않습니다. (즉, 인덱스가 없는 상황입니다.)

이 상황에서, member 목록을 보여주는 API는 각각의 member의 팔로워 수를 기준으로 정렬 및 페이징을 하도록 되어 있습니다. 하지만 팔로워 수 정보는 member 테이블만으로는 알 수 없기 때문에 서브쿼리를 활용하거나 조인을 활용해야 했습니다. JPA를 사용하고 있었기 때문에 `@Formula` 어노테이션을 활용할 수 있는 상황이기도 했고, 조인 보다는 서브쿼리로 카운트 결과만 나오는 것이 깔끔하다고 생각했기 때문에 서브쿼리로 정렬을 하도록 했습니다.

```sql
select *, (select count(1) from following f where f.following_id = m.id) f_count from member m order by f_count desc, id desc limit 199990, 10;
```

이 쿼리는 비효율적인 것을 넘어, 아예 실행도 제대로 되지 않는 쿼리입니다. 왜냐하면 member 테이블 자체만으로도 20만개의 row를 읽어야 하는 쿼리인데, following 테이블을 읽는 서브쿼리 역시 20만개의 row(더미 데이터를 20만개 넣어두었습니다.)를 읽어야 하는 쿼리였기 때문입니다.
결국 20만 x 20만 = 총 400억 개의 row를 읽어야 하는 쿼리입니다.

서브쿼리에서 조회하는 following 테이블에 인덱스를 걸면 쿼리 실행 자체는 되기는 했습니다. 하지만 그런 경우에도 10 건의 데이터를 필요로 하는 쿼리의 실행 속도가 1초나 걸리는 쿼리였습니다.

첫 번째 해결책은 정규화를 포기하는 것이었습니다. 아무리 서브쿼리에 인덱스를 태우더라도, 매 row를 읽을 때마다 서브쿼리를 실행시켜야 하기 때문에 굉장히 비효율적입니다. 이렇게 서브쿼리를 쓰게 된 이유는 다름 아닌 정규화 때문이었는데, 데이터베이스 반정규화를 하여 member 테이블 내에 follower_count 라는 컬럼을 추가해 주었습니다.
이렇게 하면 following 삽입, 수정, 삭제마다 member 테이블 쪽도 바뀌어야 하기 때문에 삽입 수정 삭제에서는 성능이 떨어지지만, 요청의 절대 다수를 차지하는 조회 상황에서 성능을 챙길 수 있습니다. 쿼리가 다음과 같이 바뀌게 됩니다.

```sql
select * from member order by follower_count desc, id desc limit 199990, 10);
```

이렇게 바꿔주니 쿼리 실행 속도를 0.26초까지 감소시킬 수 있었습니다.

하지만 여전히 문제가 남아있었습니다. 인덱스를 타지 못한다는 것이죠. 20만건에서도 0.26초나 나오는데, 데이터가 더 많아지면 똑같이 1초를 넘어가는 쿼리가 만들어질 것입니다. 때문에 인덱스를 타야 하는데요, order by 절의 경우 인덱스를 사용하기 위해서는 순서와 오름차순 / 내림차순 까지 같아야 하기 때문에 (follower_count desc, id desc)로 다중 컬럼 인덱스를 만들어 주었습니다.

하지만 실행 계획을 확인해보면 인덱스를 타지 않습니다.

![image](https://user-images.githubusercontent.com/66253212/192092100-fac4bc1a-6a15-49df-a91e-f18dc85e5e28.png)

이는 offset 페이징 방식의 한계입니다. 정렬을 하려면 테이블을 직접 읽어야 하고, 페이징 크기 상 어차피 테이블 풀 스캔에 가깝게 읽어야 하기 때문에 인덱스를 굳이 탈 이유가 없다고 판단하는 것입니다. no offset 방식의 페이징을 하면 인덱스를 태울 수 있어 훨씬 빠르겠지만, 정렬 조건에 쓰이는 컬럼이 유니크하지 않기 때문에 사용할 수가 없는 상황입니다.

때문에 커버링 인덱스를 활용하였습니다.

커버링 인덱스란 쿼리의 모든 컬럼을 가지는 인덱스를 말합니다. 기본적으로 인덱스 탐색이 데이터 테이블 접근보다 월등히 빠릅니다. 만약 커버링 인덱스를 사용하여 쿼리의 select, where, order by 등에 들어가는 컬럼이 모두 인덱스에 포함된다면, 인덱스만 탐색하고 데이터 테이블에는 접근하지 않아도 되어 성능을 개선할 수 있습니다. 따라서 어차피 풀 스캔을 할거라면 최대한 인덱스를 읽고, 테이블에 직접 접근하는 수는 줄이자가 튜닝의 핵심 개념이라고 생각하면 되겠습니다.

쿼리는 다음과 같습니다.
```sql
select * from member m join (select id from member order by follower_count desc, id desc limit 199990, 10) temp on temp.id = m.id;
```

join 안쪽의 서브쿼리를 실행하는데 필요한 컬럼은 id와 follower_count, 그 중에서도 order by 때문에 follower_count desc, id desc 입니다. 인덱스 순서와 정렬 순서가 다르면 인덱스를 적용할 수 없기 때문입니다. 서브쿼리에 정렬과 페이징이 들어가기 때문에, 서브쿼리의 결과로 테이블에 접근해야 하는 id 10개가 정렬된 상태로 나오게 됩니다. 그 뒤 조인하여 메인 쿼리를 실행하므로, 딱 10번의 데이터 접근만 하고도 필요한 데이터를 다 가져올 수 있습니다.

또한 가져오는 값이 id, 즉 클러스터 인덱스기 때문에 주소를 검색하는 추가 작업 없이 데이터 테이블에 바로 접근할 수 있습니다.

![](https://velog.velcdn.com/images/ohzzi/post/5c133d66-4145-4df8-8563-a20b10e77ad9/image.png)

쿼리 실행 결과입니다. 반정규화 이전 1초, 커버링 인덱스를 적용하기 전 0.25초 걸리던 쿼리가 0.06초로 압도적으로 빨라진 것을 볼 수 있습니다.
